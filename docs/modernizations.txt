use
===
override
explicit
const locals
const parameter
const methods
range-based for
make_unique
make_shared
=delete
=default
initializer list
virtual destructors
static_cast
const_cast
accessor methods
coding standard
namespace nesting
method docstring
class docstring
module docstring
doxygen documentation in headers
noexcept
unit tests
final classes
final methods
[[nodiscard]]
[[maybe_unused]]
[[deprecated]]
auto type deduction
trailing return types
enum class
constexpr variables
constexpr functions
inline variables
structured bindings
if constexpr
std::optional
std::variant
std::string_view
std::array
emplace methods
move semantics
uniform initialization
in-class member initializers
delegating constructors
inheriting constructors
owner<T>/nonowner<T> pointer annotations
silence warnings without changing behaviour
expand abbreviated symbols (scr→screen, idx→index, px→pixel)
enforce naming conventions (m_ for members, s_ for statics)

remove
======
dead code
commented-out code
redundant code
unused parameters
unused using
std::bind with lambdas
void argument list
Hungarian notation / RPN
duplicate includes
C header files
C-style array
malloc/free
new/delete
redundant casting
redundant control flow
redundant expressions
redundant initialization
redundant semicolons
redundant this->
empty destructors
empty default constructors
unnecessary forward declarations
trivial getters/setters
redundant null checks after new (new throws on failure)

replace
=======
pointer with reference
raw ptr with unique_ptr
raw ptr with shared_ptr
char* with string class
char* with custom C::string wrapper
malloc/free with new/delete
array pointer/length parameter with span 
macro values with const values
conditional feature macros with constexpr/consteval 
macro function with inline function
header guards with #pragma once
const values by enums
assert with static_assert
typedef with using
static with anonymous namespace
pointer 0/NULL with nullptr
bool 0/1 with true/false
printf/sprintf with iostream or std::format
strcpy/strcat with std::string
strcmp with std::string::compare or ==
memcpy/memset with std::copy/std::fill
atoi/atof with std::stoi/std::stod
rand() with <random>
time(NULL) with <chrono>
pair.first/second with structured bindings
std::auto_ptr with std::unique_ptr
throw() with noexcept
register keyword (remove)
extern template (add where beneficial)
POD struct with aggregate initialization
manual RAII with standard RAII wrappers
output parameters with return values
error codes with exceptions or std::expected
callback functions with std::function
void* with templates or std::any
union with std::variant
bitfields with std::bitset
manual string formatting with std::format
iterator pairs with ranges
begin()/end() with range-based for
push_back with emplace_back
insert with emplace
copy assignment with move assignment
C-style function pointers with std::function

refactor
========
split long methods
extract inlined code from long functions
declare variables where assigned
extract named constants
extract helper functions
reduce nesting depth
simplify boolean expressions
consolidate duplicate code
separate concerns into classes
apply design patterns (Strategy, Factory, Observer, etc.)
introduce dependency injection
convert inheritance to composition
extract interfaces from concrete classes
replace switch/if chains with polymorphism
apply SOLID principles
convert procedural code to OOP
extract reusable components/libraries
introduce layered architecture
